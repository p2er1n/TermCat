# 请先阅读本APP的代码，总结本APP的主要功能内容
_Exported on 01/22/2026 at 17:06:52 GMT+8 from OpenAI Codex via WayLog_


**OpenAI Codex**

<permissions instructions>Filesystem sandboxing defines which files can be read or written. `sandbox_mode` is `read-only`: The sandbox only permits reading files. Network access is restricted. Approvals are your mechanism to get user consent to run shell commands without the sandbox. `approval_policy` is `on-request`: Commands will be run in the sandbox by default, and you can specify in your tool call if you want to escalate a command to run without sandboxing. If the completing the task requires escalated permissions, Do not let these settings or the sandbox deter you from attempting to accomplish the user's task.

Here are scenarios where you'll need to request approval:
- You need to run a command that writes to a directory that requires it (e.g. running tests that write to /var)
- You need to run a GUI app (e.g., open/xdg-open/osascript) to open browsers or files.
- You are running sandboxed and need to run a command that requires network access (e.g. installing packages)
- If you run a command that is important to solving the user's query, but it fails because of sandboxing, rerun the command with approval. ALWAYS proceed to use the `sandbox_permissions` and `justification` parameters - do not message the user before requesting approval for the command.
- You are about to take a potentially destructive action such as an `rm` or `git reset` that the user did not explicitly ask for.

When requesting approval to execute a command that will require escalated privileges:
  - Provide the `sandbox_permissions` parameter with the value `"require_escalated"`
  - Include a short, 1 sentence explanation for why you need escalated permissions in the justification parameter</permissions instructions>

---


**User**

请先阅读本APP的代码，总结本APP的主要功能内容

---


**OpenAI Codex**

我已通读主要代码，APP 的核心功能是“在任意应用中浮窗截屏 + OCR + LLM 风险条款分析”，并把结果以浮窗/详情页展示。

主要功能概览：
- 悬浮窗入口：开启系统悬浮窗权限后启动浮窗，点击浮窗触发截屏与分析，结果在底部结果卡片展示，可复制或查看完整结果。`app/src/main/java/org/p2er1n/termcat/FloatingWindowService.kt`
- 屏幕截图与自动滚动：通过 MediaProjection 截屏，结合无障碍服务自动滚动长文本页面，最多可配置 1–120 次滚动；对多页截图做去重合并。`app/src/main/java/org/p2er1n/termcat/ScreenshotService.kt`、`app/src/main/java/org/p2er1n/termcat/AccessibilityScrollService.kt`
- OCR 识别：支持 ML Kit（中文+英文）和 PaddleOCR（内置模型）两种引擎可选。`app/src/main/java/org/p2er1n/termcat/ScreenshotService.kt`、`app/src/main/java/org/p2er1n/termcat/PaddleOcrEngine.kt`
- LLM 风险检测：将 OCR 文本按系统提示词请求 OpenAI 风格接口，返回“潜在问题”文本。`app/src/main/java/org/p2er1n/termcat/ScreenshotService.kt`、`app/src/main/res/raw/llm_system_prompt.txt`
- 设置与状态页：主页提供悬浮窗开关、无障碍引导、OCR 引擎切换、最大滚动步数、LLM endpoint/model/key 配置与状态显示。`app/src/main/java/org/p2er1n/termcat/MainActivity.kt`、`app/src/main/res/values/strings.xml`
- 结果详情页：用于显示完整分析文本。`app/src/main/java/org/p2er1n/termcat/ResultDetailActivity.kt`

如果需要更深入的流程梳理（比如完整数据流、线程/生命周期、或权限交互细节），告诉我关注哪一块即可。

---


**User**

现在遇到一个运行时的问题，当选择OCR使用paddleocr的时候，偶然会报错然后停止，报错部分的日志如下：
```
2026-01-22 17:05:02.625 22879-29512 libc                    org.p2er1n.termcat                   A  Fatal signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 0xb400006ee0280700 in tid 29512 (DefaultDispatch), pid 22879 (.p2er1n.termcat)
2026-01-22 17:05:02.625 22879-29512 libc                    org.p2er1n.termcat                   I  clone child process pid:31683
2026-01-22 17:05:02.626 22879-29512 libc                    org.p2er1n.termcat                   I  debuggerd pseudothread crash_process: 29512
---------------------------- PROCESS STARTED (31684) for package org.p2er1n.termcat ----------------------------
2026-01-22 17:05:02.676 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run end
2026-01-22 17:05:02.676 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp output tensor[0] size 6625
2026-01-22 17:05:02.676 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp rec word size 1
2026-01-22 17:05:02.677 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run start 991008
2026-01-22 17:05:02.688 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run end
2026-01-22 17:05:02.688 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp output tensor[0] size 2
2026-01-22 17:05:02.688 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp cls output scores [1.000000]
2026-01-22 17:05:02.688 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp cls output scores [0.000000]
2026-01-22 17:05:02.688 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp cls word cls 0, 1.000000
2026-01-22 17:05:02.689 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run start 991008
2026-01-22 17:05:03.085 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run end
2026-01-22 17:05:03.085 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp output tensor[0] size 503500
2026-01-22 17:05:03.089 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp rec word size 10
2026-01-22 17:05:03.090 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run start 991008
2026-01-22 17:05:03.093 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run end
2026-01-22 17:05:03.093 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp output tensor[0] size 2
2026-01-22 17:05:03.093 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp cls output scores [0.999999]
2026-01-22 17:05:03.093 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp cls output scores [0.000001]
2026-01-22 17:05:03.094 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp cls word cls 0, 0.999999
2026-01-22 17:05:03.095 22879-29508 OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run start 991008
2026-01-22 17:05:03.169 31689-31689 DEBUG                   pid-31689                            A  Cmdline: org.p2er1n.termcat
2026-01-22 17:05:03.169 31689-31689 DEBUG                   pid-31689                            A  pid: 22879, tid: 29512, name: DefaultDispatch  >>> org.p2er1n.termcat <<<
2026-01-22 17:05:03.169 31689-31689 DEBUG                   pid-31689                            A        #00 pc 0000000000151b50  /data/app/~~MopSs88yUV2IAIMHm2q78w==/org.p2er1n.termcat-jJmG1yOGZT_y4n4fwlm6dg==/base.apk!libpaddle_light_api_shared.so (offset 0x14d0000) (BuildId: 1c4ca4e6c2ba3875e559193af572028b1be98988)
```

---


**OpenAI Codex**

已在 `app/src/main/java/org/p2er1n/termcat/PaddleOcrEngine.kt` 加了进程级串行锁，确保 PaddleOCR 的 `run` 只会单线程进入（含初始化和执行），以规避底层 native 在并发/重入时偶发 SIGSEGV 的问题。这个类型的崩溃通常无法在 Kotlin 层捕获，只能通过序列化调用来规避。

说明与理由：
- 崩溃发生在 `libpaddle_light_api_shared.so`，属于 native 层异常；从日志看是在推理线程运行中崩溃。
- PaddleOCR 的 Android 绑定一般不保证线程安全；序列化调用是常见稳定化手段。

如果你希望进一步增强稳定性，还可以考虑：
1) 在 `ScreenshotService` 中加“当前正在处理”标志，阻止并发启动捕获流程。  
2) 给 PaddleOCR 单独建一个 `HandlerThread`/单线程执行器，确保所有调用固定在同一线程上。

需要我继续加第 1 或 2 点的话告诉我选项。

---


**User**

又在paddleocr识别过程中发生了报错：
```
2026-01-22 17:11:40.231  2725-9132  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp box  39,312,1018,312,1018,357,39,357
2026-01-22 17:11:40.231  2725-9132  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp box  42,265,1020,265,1020,302,42,302
2026-01-22 17:11:40.231  2725-9132  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp box  323,172,756,172,756,217,323,217
2026-01-22 17:11:40.231  2725-9132  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp box  45,162,101,162,101,217,45,217
2026-01-22 17:11:40.231  2725-9132  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp box  638,35,1020,35,1020,87,638,87
2026-01-22 17:11:40.232  2725-9132  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp box  56,37,306,37,306,85,56,85
2026-01-22 17:11:40.232  2725-9132  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run start 991008
2026-01-22 17:11:40.237  2725-9131  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run end
2026-01-22 17:11:40.237  2725-9131  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp output tensor[0] size 331250
2026-01-22 17:11:40.242  2725-9131  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp rec word size 9
2026-01-22 17:11:40.243  2725-9131  OCR_NDK                 org.p2er1n.termcat                   I  ocr cpp infer Run start 991008
2026-01-22 17:11:40.245  2725-9131  Paddle-Lite             org.p2er1n.termcat                   A  [F  1/22 17:11:40.245 .../lite/kernels/host/elementwise_op_func.h:340 Update] Wrong broadcast type
2026-01-22 17:11:40.245  2725-9132  Paddle-Lite             org.p2er1n.termcat                   A  [F  1/22 17:11:40.245 .../lite/kernels/host/elementwise_op_func.h:340 Update] Wrong broadcast type
2026-01-22 17:11:40.245  2725-9131  libc                    org.p2er1n.termcat                   I  debuggerd signal invoked signal:6
2026-01-22 17:11:40.245  2725-9132  libc                    org.p2er1n.termcat                   I  debuggerd signal invoked signal:6
2026-01-22 17:11:40.245  2725-9132  libc                    org.p2er1n.termcat                   I  debuggerd requestDump:0 NO_NEW_PRIVS:0
2026-01-22 17:11:40.245  2725-9131  libc                    org.p2er1n.termcat                   I  debuggerd requestDump:0 NO_NEW_PRIVS:0
2026-01-22 17:11:40.245  2725-9132  libc                    org.p2er1n.termcat                   A  Fatal signal 6 (SIGABRT), code -1 (SI_QUEUE) in tid 9132 (DefaultDispatch), pid 2725 (.p2er1n.termcat)
2026-01-22 17:11:40.249  2725-9132  libc                    org.p2er1n.termcat                   I  debuggerd pseudothread crash_process: 9132
2026-01-22 17:11:40.287  2725-9132  libc                    org.p2er1n.termcat                   I  clone child process pid:9231
---------------------------- PROCESS STARTED (9235) for package org.p2er1n.termcat ----------------------------
2026-01-22 17:11:40.708  9234-9234  DEBUG                   crash_dump64                         A  Cmdline: org.p2er1n.termcat
2026-01-22 17:11:40.708  9234-9234  DEBUG                   crash_dump64                         A  pid: 2725, tid: 9132, name: DefaultDispatch  >>> org.p2er1n.termcat <<<
2026-01-22 17:11:40.708  9234-9234  DEBUG                   crash_dump64                         A        #01 pc 00000000000d6280  /data/app/~~MopSs88yUV2IAIMHm2q78w==/org.p2er1n.termcat-jJmG1yOGZT_y4n4fwlm6dg==/base.apk!libpaddle_light_api_shared.so (offset 0x14d0000) (BuildId: 1c4ca4e6c2ba3875e559193af572028b1be98988)
---------------------------- PROCESS ENDED (2725) for package org.p2er1n.termcat ----------------------------
---------------------------- PROCESS ENDED (9235) for package org.p2er1n.termcat ----------------------------
```

---


**OpenAI Codex**

这次的崩溃日志是 `Paddle-Lite` 在 native 层 `SIGABRT`，并且报 `Wrong broadcast type`，这通常不是线程问题，而是“模型文件与 Paddle-Lite 运行时版本不匹配 / 模型文件损坏”的典型信号。Kotlin 侧无法捕获或兜底处理，进程会直接被杀。

最可能原因和解决方向：
- 模型版本不匹配：你现在用的是 `paddleocr4android:v1.2.9`，而资产是 `PP-OCRv4`（`app/src/main/assets/models/ch_PP-OCRv4/*`）。v4 模型常常需要更高版本的 Paddle-Lite/SDK。建议二选一：  
  1) 保持 `v1.2.9`，换成它官方对应的模型版本（通常是 v3 体系）  
  2) 升级 `paddleocr4android` 到支持 v4 的版本，并替换模型为对应版本
- 模型文件损坏或不完整：确保 `cls.nb/det.nb/rec.nb` 是完整文件，没有被打包压缩破坏或拷贝出错。

可选的工程性缓解（避免主进程被带崩）：
- 把 `ScreenshotService` 迁移到独立进程（`android:process=":ocr"`），即使 Paddle-Lite 崩溃也只影响 OCR 子进程；主悬浮窗仍可存活并恢复。
- 加一个“超时恢复浮窗”的兜底逻辑，避免 OCR 进程崩溃导致悬浮窗一直隐藏。

如果你希望我直接改代码，我建议先确认你要走哪条路：  
1) 保持 `paddleocr4android:v1.2.9`，改成兼容的 v3 模型  
2) 升级 `paddleocr4android` 并更新为匹配的 v4 模型  
3) 我来做 OCR 独立进程隔离（不解决 crash 根因，但避免整个 app 停止）

选一个，我就按这个方向动手。

---


**User**

选第三个，崩溃的时候能够恢复重新执行OCR

---


**OpenAI Codex**

已按你的选择把 PaddleOCR 放到独立进程并做“失败/崩溃后自动重试 + 兜底 MLKit”，这样即使 native 进程崩溃，主进程不会被带崩，并且会自动重试一次 OCR，若仍失败则转用 MLKit 完成识别。

改动点
- 新增独立进程 OCR 服务 `app/src/main/java/org/p2er1n/termcat/PaddleOcrService.kt`，运行在 `:ocr` 进程中。
- `ScreenshotService` 改为把待识别图片写到缓存文件，调用 `PaddleOcrService` 识别；超时/失败自动重试一次，仍失败则回退 MLKit。`app/src/main/java/org/p2er1n/termcat/ScreenshotService.kt`
- 清单中为 `PaddleOcrService` 声明独立进程。`app/src/main/AndroidManifest.xml`

这样能做到的恢复逻辑
- PaddleOCR 崩溃时，只会杀掉 `:ocr` 进程，不会终止浮窗主进程。
- `ScreenshotService` 等待结果超时后会自动重试一次，再失败则回退 MLKit，确保 OCR 结果仍能返回。

你可以先验证：
1) 选择 PaddleOCR 识别并多次尝试；崩溃时应不再退出主进程。  
2) 观察日志：应出现 `Paddle OCR timed out` 或 `Paddle OCR returned empty` 后转为 MLKit 结果。  

如果你希望“崩溃后继续只用 PaddleOCR 重试多次，不要回退 MLKit”，告诉我，我把重试策略改成多次重启 `:ocr` 进程且不回退。

---


**User**

解决编译报错，日志如下：
```
> Task :app:compileDebugKotlin FAILED
e: file:///C:/Users/user/AndroidStudioProjects/TermCat/app/src/main/java/org/p2er1n/termcat/PaddleOcrService.kt:28:27 Unresolved reference 'RESULT_OK'.

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':app:compileDebugKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

* Exception is:
org.gradle.api.tasks.TaskExecutionException: Execution failed for task ':app:compileDebugKotlin'.
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.lambda$executeIfValid$1(ExecuteActionsTaskExecuter.java:130)
	at org.gradle.internal.Try$Failure.ifSuccessfulOrElse(Try.java:293)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:128)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:116)
	at org.gradle.api.internal.tasks.execution.ProblemsTaskPathTrackingTaskExecuter.execute(ProblemsTaskPathTrackingTaskExecuter.java:40)
	at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)
	at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)
	at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)
	at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)
	at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:210)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:205)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:67)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:60)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:167)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:60)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:54)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)
	at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:331)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:318)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.lambda$execute$0(DefaultTaskExecutionGraph.java:314)
	at org.gradle.internal.operations.CurrentBuildOperationRef.with(CurrentBuildOperationRef.java:85)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:314)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)
	at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:459)
	at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:376)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:48)
Caused by: org.gradle.workers.internal.DefaultWorkerExecutor$WorkExecutionException: A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
	at org.gradle.workers.internal.DefaultWorkerExecutor$WorkItemExecution.waitForCompletion(DefaultWorkerExecutor.java:287)
	at org.gradle.internal.work.DefaultAsyncWorkTracker.lambda$waitForItemsAndGatherFailures$2(DefaultAsyncWorkTracker.java:130)
	at org.gradle.internal.Factories$1.create(Factories.java:31)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withoutLocks(DefaultWorkerLeaseService.java:335)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withoutLocks(DefaultWorkerLeaseService.java:318)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withoutLock(DefaultWorkerLeaseService.java:323)
	at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForItemsAndGatherFailures(DefaultAsyncWorkTracker.java:126)
	at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForItemsAndGatherFailures(DefaultAsyncWorkTracker.java:92)
	at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForAll(DefaultAsyncWorkTracker.java:78)
	at org.gradle.internal.work.DefaultAsyncWorkTracker.waitForCompletion(DefaultAsyncWorkTracker.java:66)
	at org.gradle.api.internal.tasks.execution.TaskExecution$3.run(TaskExecution.java:252)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:30)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$1.execute(DefaultBuildOperationRunner.java:27)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:67)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:60)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:167)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:60)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.run(DefaultBuildOperationRunner.java:48)
	at org.gradle.api.internal.tasks.execution.TaskExecution.executeAction(TaskExecution.java:229)
	at org.gradle.api.internal.tasks.execution.TaskExecution.executeActions(TaskExecution.java:212)
	at org.gradle.api.internal.tasks.execution.TaskExecution.executeWithPreviousOutputFiles(TaskExecution.java:195)
	at org.gradle.api.internal.tasks.execution.TaskExecution.execute(TaskExecution.java:162)
	at org.gradle.internal.execution.steps.ExecuteStep.executeInternal(ExecuteStep.java:105)
	at org.gradle.internal.execution.steps.ExecuteStep.access$000(ExecuteStep.java:44)
	at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:59)
	at org.gradle.internal.execution.steps.ExecuteStep$1.call(ExecuteStep.java:56)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:210)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:205)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:67)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:60)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:167)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:60)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:54)
	at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:56)
	at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:44)
	at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:42)
	at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:75)
	at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:55)
	at org.gradle.internal.execution.steps.PreCreateOutputParentsStep.execute(PreCreateOutputParentsStep.java:50)
	at org.gradle.internal.execution.steps.PreCreateOutputParentsStep.execute(PreCreateOutputParentsStep.java:28)
	at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:67)
	at org.gradle.internal.execution.steps.RemovePreviousOutputsStep.execute(RemovePreviousOutputsStep.java:37)
	at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:61)
	at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:26)
	at org.gradle.internal.execution.steps.CaptureOutputsAfterExecutionStep.execute(CaptureOutputsAfterExecutionStep.java:69)
	at org.gradle.internal.execution.steps.CaptureOutputsAfterExecutionStep.execute(CaptureOutputsAfterExecutionStep.java:46)
	at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:40)
	at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:29)
	at org.gradle.internal.execution.steps.BuildCacheStep.executeWithoutCache(BuildCacheStep.java:189)
	at org.gradle.internal.execution.steps.BuildCacheStep.lambda$execute$1(BuildCacheStep.java:75)
	at org.gradle.internal.Either$Right.fold(Either.java:175)
	at org.gradle.internal.execution.caching.CachingState.fold(CachingState.java:62)
	at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:73)
	at org.gradle.internal.execution.steps.BuildCacheStep.execute(BuildCacheStep.java:48)
	at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:46)
	at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:35)
	at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:75)
	at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$2(SkipUpToDateStep.java:53)
	at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:53)
	at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:35)
	at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:37)
	at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:27)
	at org.gradle.internal.execution.steps.ResolveIncrementalCachingStateStep.executeDelegate(ResolveIncrementalCachingStateStep.java:49)
	at org.gradle.internal.execution.steps.ResolveIncrementalCachingStateStep.executeDelegate(ResolveIncrementalCachingStateStep.java:27)
	at org.gradle.internal.execution.steps.AbstractResolveCachingStateStep.execute(AbstractResolveCachingStateStep.java:71)
	at org.gradle.internal.execution.steps.AbstractResolveCachingStateStep.execute(AbstractResolveCachingStateStep.java:39)
	at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:65)
	at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:36)
	at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:107)
	at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:56)
	at org.gradle.internal.execution.steps.AbstractCaptureStateBeforeExecutionStep.execute(AbstractCaptureStateBeforeExecutionStep.java:64)
	at org.gradle.internal.execution.steps.AbstractCaptureStateBeforeExecutionStep.execute(AbstractCaptureStateBeforeExecutionStep.java:43)
	at org.gradle.internal.execution.steps.AbstractSkipEmptyWorkStep.executeWithNonEmptySources(AbstractSkipEmptyWorkStep.java:125)
	at org.gradle.internal.execution.steps.AbstractSkipEmptyWorkStep.execute(AbstractSkipEmptyWorkStep.java:61)
	at org.gradle.internal.execution.steps.AbstractSkipEmptyWorkStep.execute(AbstractSkipEmptyWorkStep.java:36)
	at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:38)
	at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:36)
	at org.gradle.internal.execution.steps.LoadPreviousExecutionStateStep.execute(LoadPreviousExecutionStateStep.java:23)
	at org.gradle.internal.execution.steps.HandleStaleOutputsStep.execute(HandleStaleOutputsStep.java:75)
	at org.gradle.internal.execution.steps.HandleStaleOutputsStep.execute(HandleStaleOutputsStep.java:41)
	at org.gradle.internal.execution.steps.AssignMutableWorkspaceStep.lambda$execute$0(AssignMutableWorkspaceStep.java:35)
	at org.gradle.api.internal.tasks.execution.TaskExecution$4.withWorkspace(TaskExecution.java:289)
	at org.gradle.internal.execution.steps.AssignMutableWorkspaceStep.execute(AssignMutableWorkspaceStep.java:31)
	at org.gradle.internal.execution.steps.AssignMutableWorkspaceStep.execute(AssignMutableWorkspaceStep.java:22)
	at org.gradle.internal.execution.steps.ChoosePipelineStep.execute(ChoosePipelineStep.java:40)
	at org.gradle.internal.execution.steps.ChoosePipelineStep.execute(ChoosePipelineStep.java:23)
	at org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.lambda$execute$2(ExecuteWorkBuildOperationFiringStep.java:67)
	at org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.execute(ExecuteWorkBuildOperationFiringStep.java:67)
	at org.gradle.internal.execution.steps.ExecuteWorkBuildOperationFiringStep.execute(ExecuteWorkBuildOperationFiringStep.java:39)
	at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:46)
	at org.gradle.internal.execution.steps.IdentityCacheStep.execute(IdentityCacheStep.java:34)
	at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:48)
	at org.gradle.internal.execution.steps.IdentifyStep.execute(IdentifyStep.java:35)
	at org.gradle.internal.execution.impl.DefaultExecutionEngine$1.execute(DefaultExecutionEngine.java:61)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeIfValid(ExecuteActionsTaskExecuter.java:127)
	at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:116)
	at org.gradle.api.internal.tasks.execution.ProblemsTaskPathTrackingTaskExecuter.execute(ProblemsTaskPathTrackingTaskExecuter.java:40)
	at org.gradle.api.internal.tasks.execution.FinalizePropertiesTaskExecuter.execute(FinalizePropertiesTaskExecuter.java:46)
	at org.gradle.api.internal.tasks.execution.ResolveTaskExecutionModeExecuter.execute(ResolveTaskExecutionModeExecuter.java:51)
	at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:57)
	at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:74)
	at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:36)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.executeTask(EventFiringTaskExecuter.java:77)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:55)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter$1.call(EventFiringTaskExecuter.java:52)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:210)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:205)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:67)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:60)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:167)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:60)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:54)
	at org.gradle.api.internal.tasks.execution.EventFiringTaskExecuter.execute(EventFiringTaskExecuter.java:52)
	at org.gradle.execution.plan.LocalTaskNodeExecutor.execute(LocalTaskNodeExecutor.java:42)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:331)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$InvokeNodeExecutorsAction.execute(DefaultTaskExecutionGraph.java:318)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.lambda$execute$0(DefaultTaskExecutionGraph.java:314)
	at org.gradle.internal.operations.CurrentBuildOperationRef.with(CurrentBuildOperationRef.java:85)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:314)
	at org.gradle.execution.taskgraph.DefaultTaskExecutionGraph$BuildOperationAwareExecutionAction.execute(DefaultTaskExecutionGraph.java:303)
	at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.execute(DefaultPlanExecutor.java:459)
	at org.gradle.execution.plan.DefaultPlanExecutor$ExecutorWorker.run(DefaultPlanExecutor.java:376)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
	at org.gradle.internal.concurrent.AbstractManagedExecutor$1.run(AbstractManagedExecutor.java:48)
Caused by: org.jetbrains.kotlin.gradle.tasks.CompilationErrorException: Compilation error. See log for more details
	at org.jetbrains.kotlin.gradle.tasks.TasksUtilsKt.throwExceptionIfCompilationFailed(tasksUtils.kt:21)
	at org.jetbrains.kotlin.compilerRunner.GradleKotlinCompilerWork.run(GradleKotlinCompilerWork.kt:119)
	at org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction.execute(GradleCompilerRunnerWithWorkers.kt:76)
	at org.gradle.workers.internal.DefaultWorkerServer.execute(DefaultWorkerServer.java:63)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:66)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1$1.create(NoIsolationWorkerFactory.java:62)
	at org.gradle.internal.classloader.ClassLoaderUtils.executeInClassloader(ClassLoaderUtils.java:100)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.lambda$execute$0(NoIsolationWorkerFactory.java:62)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:44)
	at org.gradle.workers.internal.AbstractWorker$1.call(AbstractWorker.java:41)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:210)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$CallableBuildOperationWorker.execute(DefaultBuildOperationRunner.java:205)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:67)
	at org.gradle.internal.operations.DefaultBuildOperationRunner$2.execute(DefaultBuildOperationRunner.java:60)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:167)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.execute(DefaultBuildOperationRunner.java:60)
	at org.gradle.internal.operations.DefaultBuildOperationRunner.call(DefaultBuildOperationRunner.java:54)
	at org.gradle.workers.internal.AbstractWorker.executeWrappedInBuildOperation(AbstractWorker.java:41)
	at org.gradle.workers.internal.NoIsolationWorkerFactory$1.execute(NoIsolationWorkerFactory.java:59)
	at org.gradle.workers.internal.DefaultWorkerExecutor.lambda$submitWork$0(DefaultWorkerExecutor.java:174)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runExecution(DefaultConditionalExecutionQueue.java:194)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.access$700(DefaultConditionalExecutionQueue.java:127)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner$1.run(DefaultConditionalExecutionQueue.java:169)
	at org.gradle.internal.Factories$1.create(Factories.java:31)
	at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:263)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:127)
	at org.gradle.internal.work.DefaultWorkerLeaseService.runAsWorkerThread(DefaultWorkerLeaseService.java:132)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.runBatch(DefaultConditionalExecutionQueue.java:164)
	at org.gradle.internal.work.DefaultConditionalExecutionQueue$ExecutionRunner.run(DefaultConditionalExecutionQueue.java:133)
	... 2 more


BUILD FAILED in 3s
```

---


**OpenAI Codex**

已修复编译错误：`RESULT_OK` 改为 `Activity.RESULT_OK` 并补上 `Activity` 的 import。  
改动文件：`app/src/main/java/org/p2er1n/termcat/PaddleOcrService.kt`

建议下一步：
1) 重新编译 `./gradlew :app:assembleDebug`  
2) 如果还有新错误，把日志发我继续处理

---


**User**

频繁出现这个日志，这个是否就是paddleocr失败的原因：
```
2026-01-22 17:20:40.845 18464-19309 Paddle-Lite             org.p2er1n.termcat                   I  [I  1/22 17:20:40.845 ...and/Paddle-Lite/lite/core/device_info.cc:591 bind_threads] Set cpu affinity failed, core id: 4
```

---


**OpenAI Codex**

不是。这条日志只是 Paddle-Lite 在尝试绑 CPU 核心亲和性时失败了，属于性能优化失败的提示，通常不会导致 OCR 失败或崩溃。它不会直接影响推理正确性，最多是性能略有波动。真正导致崩溃的还是之前那类 `Wrong broadcast type` 或 native SIGABRT/SIGSEGV。

---


**User**

这两行日志是什么意思，有帮助吗：
```
2026-01-22 17:24:19.929 22049-22059 r1n.termcat:ocr         org.p2er1n.termcat                   I  NativeAlloc concurrent copying GC freed 209KB AllocSpace bytes, 2(56KB) LOS objects, 49% free, 2905KB(NonMov:56KB, MS:1009KB + LOS:1840KB)/5810KB, paused 116us,49us total 927.116ms cpu 46.800ms, itvl 12.535s, na, bg
2026-01-22 17:24:19.956 22049-22066 r1n.termcat:ocr         org.p2er1n.termcat                   I  WaitForGcToComplete blocked ProfileSaver on NativeAlloc for 754.999ms
```

---


**OpenAI Codex**

这是 Android 运行时的 GC 日志，表示 `:ocr` 进程在做并发复制 GC，释放了一些内存，并且 `ProfileSaver` 等待 GC 完成被阻塞了 ~755ms。  
含义/帮助：
- 这是正常的内存回收信息，不是错误。
- 只能说明当时内存压力较大或分配频繁，可能带来卡顿/耗时，但不会直接导致 OCR 崩溃。

---


**User**

再次阅读paddleocr库的文档，查看是否代码编写的不正确：
```
[![](https://jitpack.io/v/equationl/paddleocr4android.svg)](https://jitpack.io/#equationl/paddleocr4android)

# 简介

该库是对 [PaddleOCR](https://github.com/PaddlePaddle/PaddleOCR) 中的 [android_demo](https://github.com/PaddlePaddle/PaddleOCR/tree/release/2.5/deploy/android_demo) 进行二次封装的库。
对于只想体验或者快速上手使用的安卓开发者，该库对官方 demo 进行了简单的封装，使其可以直接上手使用，而无需关心 PaddleOCR 的实现，亦无需进行繁琐的配置。

基于 *Paddle-Lite* 部署

截图：

![截图](/doc/screenshot1.jpg)

# 注意

本库基于 *Paddle-Lite* 部署，因此只支持 Paddle-Lite 模型（格式 `.nb`） 目前 Paddle-Lite 版本为 2.14-rc，已支持 PPOCRv4 模型。

您也可以尝试使用 [fastDeployOCR](/README.md) 部署。

# 使用方法

无需进行任何配置，直接运行 demo （[app](../app)）即可体验。

如需集成至您自己的项目中，请按下述步骤进行：

## 1.下载依赖

首先，根据你使用的 Gradle 版本在项目级 *build.gradle* 或 *settings.gradle* 文件添加 jitpack 远程仓库：

```gradle
allprojects {
	repositories {
		...
		maven { url 'https://jitpack.io' }
	}
}
```

然后在 Module 级 *build.gradle* 文件添加依赖：

```gradle
dependencies {
    implementation 'com.github.equationl.paddleocr4android:paddleocr4android:v1.2.9'
    
    // 如果需要包含 OpenCL 预测库，请使用下面这个依赖
    //implementation 'com.github.equationl:paddleocr4android:v1.1.1-OpenCL'
}
```

## 2.下载模型

### 下载模型的渠道
1. 去官网下载

模型下载地址: [Paddle-Lite模型](https://paddlepaddle.github.io/PaddleOCR/latest/ppocr/model_list.html)

**注意：当前本库最新版本使用的 Paddle-Lite 版本为 2.14-rc，已支持 PPOCRv4 模型，为了保证良好的识别效果，请使用相同版本的 paddle-lite [opt 工具](https://www.paddlepaddle.org.cn/lite/v2.12/user_guides/model_optimize_tool.html)对模型进行量化**

更多模型请自行前往 PaddleOCR 官网下载。

2. 直接使用demo中的模型

demo 中已经集成了 ch_PP-OCRv2 模型（官方提供）和 ch_PP-OCRv4 模型（@[dwh](https://github.com/dengwhao)提供），可以直接复制使用

文件路径 /app/src/main/assets/models/ch_PP-OCRv2/ 以及 /app/src/main/assets/models/ch_PP-OCRv4/

需要注意的是，由于是基于 *Paddle-Lite* 部署，所以只能使用 `*.nb` 格式的slim模型。

请将下载好的三个模型：

```
xx_cls.nb
xx_det.nb
xx_rec.nb
```

放置到手机任意目录或项目的 **assets** 的目录下。

三个模型分别为：

| 文件名       | 模型名称     | 说明       |
|-----------|----------|----------|
| xx_cls.nb | 文本方向分类模型 | 用于文本方向分类 |
| xx_det.nb | 检测模型     | 用于检测文本位置 |
| xx_rec.nb | 识别模型     | 用于识别文本内容 |

*建议测试时直接放到 assets 中，避免放到手机目录中时由于权限问题而无法读取模型*

*正式使用时请自行实现模型的下载，建议不要直接将模型放在 assets 中打包进安装包*

## 3.加载模型

```kotlin
// 配置
val config = OcrConfig()
//config.labelPath = null


config.modelPath = "models/ch_PP-OCRv4" // 不使用 "/" 开头的路径表示安装包中 assets 目录下的文件，例如当前表示 assets/models/ocr_v2_for_cpu
//config.modelPath = "/sdcard/Android/data/com.equationl.paddleocr4android.app/files/models" // 使用 "/" 表示手机储存路径，测试时请将下载的三个模型放置于该目录下
config.clsModelFilename = "cls.nb" // cls 模型文件名
config.detModelFilename = "det.nb" // det 模型文件名
config.recModelFilename = "rec.nb" // rec 模型文件名

// 运行全部模型
// 请根据需要配置，三项全开识别率最高；如果只开识别几乎无法正确识别，至少需要搭配检测或分类其中之一
// 也可单独运行 检测模型 获取文本位置
config.isRunDet = true
config.isRunCls = true
config.isRunRec = true

// 使用所有核心运行
config.cpuPowerMode = CpuPowerMode.LITE_POWER_FULL

// 绘制文本位置
config.isDrwwTextPositionBox = true

// 1.同步初始化
/*ocr.initModelSync(config).fold(
    {
        if (it) {
            Log.i(TAG, "onCreate: init success")
        }
    },
    {
        it.printStackTrace()
    }
)*/

// 2.异步初始化
resultText.text = "开始加载模型"
ocr.initModel(config, object : OcrInitCallback {
    override fun onSuccess() {
        resultText.text = "加载模型成功"
        Log.i(TAG, "onSuccess: 初始化成功")
    }

    override fun onFail(e: Throwable) {
        resultText.text = "加载模型失败: $e"
        Log.e(TAG, "onFail: 初始化失败", e)
    }

})
```

更多配置请自行查看 [OcrConfig.kt](/PaddleOCR4Android/src/main/java/com/equationl/paddleocr4android)

## 4.开始使用

```kotlin
// 1.同步识别
/*val bitmap = BitmapFactory.decodeResource(resources, R.drawable.test2)
          ocr.runSync(bitmap)

          val bitmap2 = BitmapFactory.decodeResource(resources, R.drawable.test3)
          ocr.runSync(bitmap2)*/

// 2.异步识别
val bitmap3 = BitmapFactory.decodeResource(resources, R.drawable.test4)
ocr.run(bitmap3, object : OcrRunCallback {
    override fun onSuccess(result: OcrResult) {
        val simpleText = result.simpleText
        val imgWithBox = result.imgWithBox
        val inferenceTime = result.inferenceTime
        val outputRawResult = result.outputRawResult

        var text = "识别文字=\n$simpleText\n识别时间=$inferenceTime ms\n更多信息=\n"

        val wordLabels = ocr.getWordLabels()
        outputRawResult.forEachIndexed { index, ocrResultModel ->
            // 文字索引（crResultModel.wordIndex）对应的文字可以从字典（wordLabels） 中获取
            ocrResultModel.wordIndex.forEach {
                Log.i(TAG, "onSuccess: text = ${wordLabels[it]}")
            }
            // 文字方向 ocrResultModel.clsLabel 可能为 "0" 或 "180"
            text += "$index: 文字方向：${ocrResultModel.clsLabel}；文字方向置信度：${ocrResultModel.clsConfidence}；识别置信度 ${ocrResultModel.confidence}；文字索引位置 ${ocrResultModel.wordIndex}；文字位置：${ocrResultModel.points}\n"
        }

        resultText.text = text
        resultImg.setImageBitmap(imgWithBox)
    }

    override fun onFail(e: Throwable) {
        resultText.text = "识别失败：$e"
        Log.e(TAG, "onFail: 识别失败！", e)
    }

})
```

## 5.其他

有任何问题请先尝试 demo 或阅读源码，如果无法解决请提 issue

国内镜像地址： [paddleocr4android](https://gitee.com/equation/paddleocr4android)

## 6.问题解决
- 提示 ` Error: This model is not supported, because kernel for 'io_copy' is not supported by Paddle-Lite.`

该提示表示您使用的模型需要 OpenCL 预测库支持。解决办法：

使用包含 OpenCL 预测库的依赖。


# 更新记录
**v1.2.0**
- PaddleLite 更新至 v2.14-rc（支持 PPOCRv4, 感谢 @[dwh](https://github.com/dengwhao) PR ）

**v1.1.0**

- PaddleLite 更新至 v2.10
- 支持单独运行 分类、检测、识别 模型
- API 变动：

```kotlin
// 移除配置项：

    var inputColorFormat: InputColorFormat
    var inputShape: LongArray
    var inputMean: FloatArray
    var inputStd: FloatArray
    
// 增加配置项：
    
    /**
     * 是否运行检测模型
     * */
    var isRunDet: Boolean = true

    /**
     * 是否运行分类模型
     * */
    var isRunCls: Boolean = true

    /**
     * 是否运行识别模型
     * */
    var isRunRec: Boolean = true

    var isUseOpencl: Boolean = false

    /**
     * 是否绘制文字位置
     *
     * 如果为 true， [OcrResult.imgWithBox] 返回的是在输入 Bitmap 上绘制出文本位置框的 Bitmap
     *
     * 否则，[OcrResult.imgWithBox] 将会直接返回输入 Bitmap
     * */
    var isDrwwTextPositionBox: Boolean = false
```
Beta
0 / 0
used queries
```

---


**OpenAI Codex**

我对照你贴的文档和当前代码实现看了一遍，整体用法是符合文档的：  
- 模型路径 `models/ch_PP-OCRv4`、`cls/det/rec` 文件名、`isRunDet/isRunCls/isRunRec`、`isDrwwTextPositionBox=false` 都在 `PaddleOcrEngine` 里设置了。  
- 初始化走了 `initModelSync`/`initModel`（通过反射选择可用接口），并且只初始化一次。  
- 识别走 `runSync` 或 `run` 回调等待完成，调用方式与文档一致。  

所以“代码写法不正确”不是主要问题，反而更像是模型/运行时不匹配导致的 native 崩溃（你之前的 `Wrong broadcast type` 就是这类典型信号）。

可能的真实问题点（更符合日志）：
- 模型与 Paddle-Lite 版本不匹配（v1.2.9 对应的模型版本、量化方式不一致）。
- 模型文件损坏或下载来源不正确（不是 `.nb`、或不是对应版本的 slim 模型）。
- 多进程/线程问题现在已经隔离了，基本不属于“API 用法错误”。

如果你想让我进一步排查“是否初始化失败或模型加载异常”，我建议再加两处日志（不会改变逻辑）：
1) 初始化成功/失败的详细 log  
2) 读取 assets 中模型文件是否存在、文件大小  

这能确定是不是模型文件本身有问题。你要我加的话说一声。

---


**User**

选择paddleocr之后，如果paddleocr经常报错，那么就不要回退到ml，就报错不再尝试

---


**OpenAI Codex**

已按你的要求取消 PaddleOCR 失败时回退到 MLKit，现在只要选择 PaddleOCR，失败就直接返回空结果，不再尝试 MLKit。修改在 `app/src/main/java/org/p2er1n/termcat/ScreenshotService.kt`。

如果你还希望在失败时弹 Toast 或展示更明确的错误提示，我可以再加。

---


**User**

现在底部通知栏的close按钮点击只关闭底部栏目，但是不结束正在进行的任务和操作对吗？

---


**OpenAI Codex**

对的。`Close` 按钮只调用 `hideResult()` 把底部结果视图隐藏，不会停止正在进行的 OCR/LLM 或截图任务。相关逻辑在 `app/src/main/java/org/p2er1n/termcat/FloatingWindowService.kt`。如果你希望它能中断当前任务，需要额外加“取消捕获/停止服务”的逻辑。

---


**User**

我希望它终端当前的任务，然后改成，stop，不叫close了

---


**OpenAI Codex**

已把“Close”改成“Stop”，点击后会发送停止指令并尽可能中断当前 OCR/LLM 流程，同时不再更新底部结果。主要改动如下：
- `app/src/main/java/org/p2er1n/termcat/FloatingWindowService.kt`：按钮改为触发 `stopCaptureAndHide()`，发送停止动作并清空结果。
- `app/src/main/java/org/p2er1n/termcat/ScreenshotService.kt`：新增 `ACTION_STOP_CAPTURE`，收到后设置取消标记、停止 `PaddleOcrService`；在 OCR/LLM 过程与广播处加取消判断，避免继续执行或更新 UI。
- `app/src/main/res/values/strings.xml`：`result_close` 文案改成 `Stop`。

你可以先做的验证：
1) 运行一次 PaddleOCR 识别，点击底部 `Stop`，确认不会再继续更新 OCR/LLM 进度。  
2) 观察日志是否仍有结果回传（应被取消过滤）。

---
